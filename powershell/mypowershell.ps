# ベーシックなデータ定義とオペレータ操作
# range operatorを使う
(1..10) | % {Write $_}
(1..10) | ForEach {Write $_} # alias1
(1..10) | ForEach-Object {Write $_} # alias2

# 配列を使う
(1,2,3) | % {Write $_}

# 連想配列（ハッシュテーブル）を使う
# @{k1=v1,k2=v2) this is defined as [hashtable]
@{"a"=1;"b"=2}.keys | % {Write $_} # list of names
@{"a"=1;"b"=2}.values | % {Write $_} # list of values
 
# Todo 直接操作すると操作できない件の調査、オブジェクトの型が違うのか、
$h = @{"a"=1};$h.Add("b",2);Write $h

# オブジェクト指向＋プロトタイプ
# TODO 前述のメンバー変数へアクセスするための方法this.Name的な表現が上手く通らない
#| Add-Member -MemberType ScriptMethod -Name say -Value {"hello"+Get-Member($This.Name)} -PassThru
$MamalClass = {$MyInvocation.MyCommand.ScriptBlock `
    | Add-Member -PassThru -MemberType NoteProperty -Name Name -Value "mamal" `
    | Add-Member -MemberType ScriptMethod -Name hello -Value {"hello"} -PassThru
}
$obj = &$MamalClass
$obj.hello()

# 日付系
(Get-Date).ToString("yyyyMMddhhmmss")

# snipet for Function and Commandlet
function CommandletName {
    param(
        [Parameter(ValueFromPipeline=$true,Mandatory=$true)]
        #[type]paramname,
        #[type]paramname,
        #[type]paramname
    )
    begin{}
    #main process
    process{}
    end{}
}

############################################################
#
# データ生成系
#
############################################################
# 44KByteのサイズの任意の文字列のファイルを生成する
$value = "0" * (44 * 1024)
$date = (Get-Date).ToString("yyyyMMddhhmmss")
New-Item -Type file -Value $value "test$date"

# urlencodeを行う
# デフォルトではライブラリがロードされていないのでしておく
# output : http%3a%2f%2ftest.com%2fgetparam%3d!%23%24%25%26%27(
Add-Type -AssemblyName System.Web
[System.Web.HttpUtility]::UrlEncode("http://test.com/getparam=!#$%&'(")

# urldecodeを行う
# output : http://test.com/getparam=!#$%&'(
[System.Web.HttpUtility]::UrlDecode("http%3a%2f%2ftest.com%2fgetparam%3d!%23%24%25%26%27(")

# 文字列をbase64にencodeする
Write-Host -NoNewline [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("TEST!#$%&'()"))

# basic認証用の文字列を生成する
# username, password, basic authentication stringで出力する
function Get-BasicAuth
{
    param(
        [Parameter(ValueFromPipeline=$true,Mandatory=$true)]
        [String]$Username="ino9dev",
        [String]$Password="ino9dev's password"
    )
    begin{}
    process{
        $authbase = $Username + ":" + $Password;
        $basic = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($authbase));
        $basic;
    }
    end{}
}
Get-BasicAuth -Username "ino9dev" -Password "ino9dev's password"

# ランダムな文字列を生成する（charsetを与えて10文字出力）
function Get-RandomStr {
    param(
        [Parameter(ValueFromPipeline=$true,Mandatory=$true)]
        [int32]$Count = 10,
        char[]$Charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"#$%&\`('.ToCharArray()
    )
    begin{}
    process{
        $result = Get-Random $Charset -Count $Count
# TODO resultをそのまま出力すると、改行的内容が含まれるのでそれを除外したい
#        $hoge = [String]::Join("`n",$result)
#        $hoge
    }
    end{
    }
}
Get-RandomStr -Count 10

# 規則的な複数ユーザID,パスワードを生成する（USER001-USER010）
(0..10) | % {Write ($_.ToString("USER000") +","+ $_.ToString("PASS000"))}

# 複数ユーザ分（パスワードはPASSWORD）のbasic認証文字列を生成する(10ユーザ分） 
# 前述のGet-BasicAuthを使用する
(0..10) | % {Get-BasicAuth -Username $_.ToString("USER000") -Password $_.ToString("PASS000")}

# お遊び
# random walk 1
(0..99) | % {@("a","b") | Get-Random} | {switch($_){"a"{-1} "b"{+1}}}

# random walk 2
# 100000の数字の中から100個をランダムで取り出し、商が0の場合は+1、1の場合は-1し、それをsumした値を出力する
Get-Random -Count 100 (0..100000) | % {switch($_ % 2){0{1}1{-1}}} | measure  -sum | select -ExpandProperty Sum

############################################################
#
# ファイルシステム系
#
############################################################
# あるフォルダ配下

# フォルダのみ検索

# ある更新日付のファイルのみ検索

# あるサイズのファイルのみ検索

############################################################
#
# テスト用ツールダウンロード
#
############################################################
function DownloadTestTools {
    <#
    .DESCRIPTION テスト用のツールをダウンロードします。テストタイプによって、ダウンロードするツール群を指定します。
    #>
    param(
        [Parameter(ValueFromPipeline=$true)]
        [String]$Today=((Get-Date).ToString("yyyyMMddhhmmss")),
        [String]$Dirname="Download_$Today",
        [String]$BaseDir=".",
        [String]$Path="$BaseDir\\$Dirname",
        [String[]]$Target=("LT"),
        [HashTable]$ToolsGroup=@{
            "LT"=@{
                # "Java 6"="";
                "apache-jmeter-2.13.zip"="http://ftp.tsukuba.wide.ad.jp/software/apache//jmeter/binaries/apache-jmeter-2.13.zip";
                #"Fiddler 4"="";
                #"Atom"="";
                #"Firefox"="";
            };
            #Automated Test
            #"AT"=@{
            #    ""="";
            #    ""="";
            #};
            #"AP"=@{
            #};
            #"NW"=@{
            #    "Wireshark"="";
            #}
            #"COMMON"=@{
            #    "Eclipse"="";
            #}
        }
    )
    begin{
        #create download folder
        # TODO 既にフォルダが存在すればどうかを確認
        # TODO DL先の空き容量を確認
        # New-Item -ItemType directory -Path "$BaseDir\\$Dirname"
        md -Path $Path | out-null
    }
    process{
        # more beautiful but this code didn't work..
        #$ToolsGroup |
        #    % getEnumerator |
        #        % getEnumerator | % {$key = $($_.key);$value = $($_.value);Write "key=$key,value=$value"}
        foreach($Tools in $ToolsGroup.values){
           foreach($ToolKey in $Tools.keys){
                Write-Host -NoNewLine "Start Downloading $ToolKey"
                Invoke-WebRequest -Uri  $Tools[$ToolKey] -Outfile "$Path\$ToolKey"
            }
        }
    }
    end{
        Write ""
    }
}
DownloadTestTools