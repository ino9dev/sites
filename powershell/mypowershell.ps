# ベーシックなデータ定義とオペレータ操作
# range operatorを使う
(1..10) | % {Write $_}
(1..10) | ForEach {Write $_} # alias1
(1..10) | ForEach-Object {Write $_} # alias2

# 配列を使う
(1,2,3) | % {Write $_}

# 連想配列（ハッシュテーブル）を使う
# @{k1=v1,k2=v2) this is defined as [hashtable]
@{"a"=1;"b"=2}.keys | % {Write $_} # list of names
@{"a"=1;"b"=2}.Values | % {Write $_} # list of values
 
# Todo 直接操作すると操作できない件の調査、オブジェクトの型が違うのか、
$h = @{"a"=1};$h.Add("b",2);Write $h

# オブジェクト指向＋プロトタイプ
# TODO 前述のメンバー変数へアクセスするための方法this.Name的な表現が上手く通らない
#| Add-Member -MemberType ScriptMethod -Name say -Value {"hello"+Get-Member($This.Name)} -PassThru
$MamalClass = {$MyInvocation.MyCommand.ScriptBlock `
    | Add-Member -PassThru -MemberType NoteProperty -Name Name -Value "mamal" `
    | Add-Member -MemberType ScriptMethod -Name hello -Value {"hello"} -PassThru
}
$obj = &$MamalClass
$obj.hello()

# 日付系
(Get-Date).ToString("yyyyMMddhhmmss")

# snipet for Function and Commandlet
function CommandletName {
    param(
        [Parameter(ValueFromPipeline=$true,Mandatory=$true)]
        #[type]paramname,
        #[type]paramname,
        #[type]paramname
    )
    begin{}
    #main process
    process{}
    end{}
}

############################################################
#
# データ生成系
#
############################################################
# 44KByteのサイズの任意の文字列のファイルを生成する
New-Item -Type file -Value {Get-Random -Count 100 (0..1)} test_$

# urlencodeを行う
# デフォルトではライブラリがロードされていないのでしておく
# output : http%3a%2f%2ftest.com%2fgetparam%3d!%23%24%25%26%27(
Add-Type -AssemblyName System.Web
[System.Web.HttpUtility]::UrlEncode("http://test.com/getparam=!#$%&'(")

# urldecodeを行う
# output : http://test.com/getparam=!#$%&'(
[System.Web.HttpUtility]::UrlDecode("http%3a%2f%2ftest.com%2fgetparam%3d!%23%24%25%26%27(")

# 文字列をbase64にencodeする
Write-Host -NoNewline [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("TEST!#$%&'()"))

# basic認証用の文字列を生成する
# username, password, basic authentication stringで出力する
function Get-BasicAuth
{
    param(
        [Parameter(ValueFromPipeline=$true,Mandatory=$true)]
        [String]$Username="ino9dev",
        [String]$Password="ino9dev's password"
    )
    begin{}
    process{
        $authbase = $Username + ":" + $Password;
        $basic = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($authbase));
        $basic;
    }
    end{}
}
Get-BasicAuth -Username "ino9dev" -Password "ino9dev's password"

# ランダムな文字列を生成する（charsetを与えて10文字出力）
function Get-RandomStr {
    param(
        [Parameter(ValueFromPipeline=$true,Mandatory=$true)]
        [int32]$Count = 10,
        $Charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"#$%&\`('.ToCharArray()
    )
    begin{}
    process{
        $result = Get-Random $Charset -Count $Count
# TODO resultをそのまま出力すると、改行的内容が含まれるのでそれを除外したい
#        $hoge = [String]::Join("`n",$result)
#        $hoge
    }
    end{
    }
}
Get-RandomStr -Count 10

# 規則的な複数ユーザID,パスワードを生成する（USER001-USER010）
(0..10) | % {Write ($_.ToString("USER000") +","+ $_.ToString("PASS000"))}

# 複数ユーザ分（パスワードはPASSWORD）のbasic認証文字列を生成する(10ユーザ分） 
# 前述のGet-BasicAuthを使用する
(0..10) | % {Get-BasicAuth -Username $_.ToString("USER000") -Password $_.ToString("PASS000")}

# お遊び
# random walk 1
(0..99) | % {@("a","b") | Get-Random} | {switch($_){"a"{-1} "b"{+1}}}

# random walk 2
# 100000の数字の中から100個をランダムで取り出し、商が0の場合は+1、1の場合は-1し、それをsumした値を出力する
Get-Random -Count 100 (0..100000) | % {switch($_ % 2){0{1}1{-1}}} | measure  -sum | select -ExpandProperty Sum
